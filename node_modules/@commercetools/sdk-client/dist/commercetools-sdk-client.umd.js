(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('querystring'), require('http')) :
	typeof define === 'function' && define.amd ? define(['exports', 'querystring', 'http'], factory) :
	(factory((global.CommercetoolsSdkClient = {}),global.qs,global.http));
}(this, (function (exports,qs,http) { 'use strict';

qs = qs && qs.hasOwnProperty('default') ? qs['default'] : qs;

function validate(funcName, request) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : { allowedMethods: http.METHODS };

  if (!request)
    // eslint-disable-next-line max-len
    throw new Error('The "' + funcName + '" function requires a "Request" object as an argument. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest');

  if (typeof request.uri !== 'string')
    // eslint-disable-next-line max-len
    throw new Error('The "' + funcName + '" Request object requires a valid uri. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest');

  if (!(options.allowedMethods.indexOf(request.method) !== -1))
    // eslint-disable-next-line max-len
    throw new Error('The "' + funcName + '" Request object requires a valid method. See https://commercetools.github.io/nodejs/sdk/Glossary.html#clientrequest');
}

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};





















var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/*       */
function compose() {
  for (var _len = arguments.length, funcs = Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }

  // eslint-disable-next-line no-param-reassign
  funcs = funcs.filter(function (func) {
    return typeof func === 'function';
  });

  if (funcs.length === 1) return funcs[0];

  return funcs.reduce(function (a, b) {
    return function () {
      return a(b.apply(undefined, arguments));
    };
  });
}

function createClient(options) {
  if (!options) throw new Error('Missing required options');

  if (options.middlewares && !Array.isArray(options.middlewares)) throw new Error('Middlewares should be an array');

  if (!options.middlewares || !Array.isArray(options.middlewares) || !options.middlewares.length) throw new Error('You need to provide at least one middleware');

  return {
    /*
      Given a request object,
    */
    execute: function execute(request) {
      validate('exec', request);

      return new Promise(function (resolve, reject) {
        var resolver = function resolver(rq, rs) {
          // Note: pick the promise `resolve` and `reject` function from
          // the response object. This is not necessary the same function
          // given from the `new Promise` constructor, as middlewares could
          // override those functions for custom behaviours.
          if (rs.error) rs.reject(rs.error);else {
            var resObj = {
              body: rs.body || {},
              statusCode: rs.statusCode
            };
            if (rs.headers) resObj.headers = rs.headers;
            if (rs.request) resObj.request = rs.request;
            rs.resolve(resObj);
          }
        };

        var dispatch = compose.apply(undefined, toConsumableArray(options.middlewares))(resolver);
        dispatch(request,
        // Initial response shape
        {
          resolve: resolve,
          reject: reject,
          body: undefined,
          error: undefined
        });
      });
    },
    process: function process(request, fn, processOpt) {
      var _this = this;

      validate('process', request, { allowedMethods: ['GET'] });

      if (typeof fn !== 'function')
        // eslint-disable-next-line max-len
        throw new Error('The "process" function accepts a "Function" as a second argument that returns a Promise. See https://commercetools.github.io/nodejs/sdk/api/sdkClient.html#processrequest-processfn-options');

      // Set default process options
      var opt = _extends({
        total: Number.POSITIVE_INFINITY,
        accumulate: true
      }, processOpt);
      return new Promise(function (resolve, reject) {
        var _request$uri$split = request.uri.split('?'),
            _request$uri$split2 = slicedToArray(_request$uri$split, 2),
            path = _request$uri$split2[0],
            queryString = _request$uri$split2[1];

        var requestQuery = _extends({}, qs.parse(queryString));
        var query = _extends({
          // defaults
          limit: 20
        }, requestQuery);

        var itemsToGet = opt.total;
        var processPage = function processPage(lastId) {
          var acc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

          // Use the lesser value between limit and itemsToGet in query
          var limit = query.limit < itemsToGet ? query.limit : itemsToGet;
          var originalQueryString = qs.stringify(_extends({}, query, { limit: limit }));

          var enhancedQuery = _extends({
            sort: 'id asc',
            withTotal: false
          }, lastId ? { where: 'id > "' + lastId + '"' } : {});
          var enhancedQueryString = qs.stringify(enhancedQuery);
          var enhancedRequest = _extends({}, request, {
            uri: path + '?' + enhancedQueryString + '&' + originalQueryString
          });

          _this.execute(enhancedRequest).then(function (payload) {
            fn(payload).then(function (result) {
              var resultsLength = payload.body.results.length;
              var accumulated = void 0;
              if (opt.accumulate) accumulated = acc.concat(result || []);

              itemsToGet -= resultsLength;
              // If there are no more items to get, it means the total number
              // of items in the original request have been fetched so we
              // resolve the promise.
              // Also, if we get less results in a page then the limit set it
              // means that there are no more pages and that we can finally
              // resolve the promise.
              if (resultsLength < query.limit || !itemsToGet) {
                resolve(accumulated || []);
                return;
              }

              var last = payload.body.results[resultsLength - 1];
              var newLastId = last && last.id;
              processPage(newLastId, accumulated);
            }).catch(reject);
          }).catch(reject);
        };

        // Start iterating through pages
        processPage();
      });
    }
  };
}

// eslint-disable-next-line import/prefer-default-export

exports.createClient = createClient;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=commercetools-sdk-client.umd.js.map
