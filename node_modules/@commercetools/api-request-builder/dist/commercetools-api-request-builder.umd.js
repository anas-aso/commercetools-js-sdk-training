(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.CommercetoolsApiRequestBuilder = {})));
}(this, (function (exports) { 'use strict';

var query = 'query';
var queryOne = 'queryOne';
var queryExpand = 'queryExpand';
var queryLocation = 'queryLocation';
var search = 'search';
var projection = 'projection';
var suggest = 'suggest';

var features = Object.freeze({
	query: query,
	queryOne: queryOne,
	queryExpand: queryExpand,
	queryLocation: queryLocation,
	search: search,
	projection: projection,
	suggest: suggest
});

var services = {
  cartDiscounts: {
    type: 'cart-discounts',
    endpoint: '/cart-discounts',
    features: [query, queryOne, queryExpand]
  },
  carts: {
    type: 'carts',
    endpoint: '/carts',
    features: [query, queryOne, queryExpand]
  },
  categories: {
    type: 'categories',
    endpoint: '/categories',
    features: [query, queryOne, queryExpand]
  },
  channels: {
    type: 'channels',
    endpoint: '/channels',
    features: [query, queryOne, queryExpand]
  },
  customerGroups: {
    type: 'customer-groups',
    endpoint: '/customer-groups',
    features: [query, queryOne, queryExpand]
  },
  customers: {
    type: 'customers',
    endpoint: '/customers',
    features: [query, queryOne, queryExpand]
  },
  customObjects: {
    type: 'custom-objects',
    endpoint: '/custom-objects',
    features: [query, queryOne]
  },
  discountCodes: {
    type: 'discount-codes',
    endpoint: '/discount-codes',
    features: [query, queryOne, queryExpand]
  },
  extensions: {
    type: 'extensions',
    endpoint: '/extensions',
    features: [query, queryOne, queryExpand]
  },
  inventory: {
    type: 'inventory',
    endpoint: '/inventory',
    features: [query, queryOne, queryExpand]
  },
  messages: {
    type: 'messages',
    endpoint: '/messages',
    features: [query, queryOne, queryExpand]
  },
  myCarts: {
    type: 'my-carts',
    endpoint: '/me/carts',
    features: [query, queryOne, queryExpand]
  },
  myOrders: {
    type: 'my-orders',
    endpoint: '/me/orders',
    features: [query, queryOne, queryExpand]
  },
  orders: {
    type: 'orders',
    endpoint: '/orders',
    features: [query, queryOne, queryExpand]
  },
  orderImport: {
    type: 'orderImport',
    endpoint: '/orders/import',
    features: [query]
  },
  payments: {
    type: 'payments',
    endpoint: '/payments',
    features: [query, queryOne, queryExpand]
  },
  productDiscounts: {
    type: 'product-discounts',
    endpoint: '/product-discounts',
    features: [query, queryOne, queryExpand]
  },
  productProjections: {
    type: 'product-projections',
    endpoint: '/product-projections',
    features: [query, queryOne, queryExpand, projection]
  },
  productProjectionsSearch: {
    type: 'product-projections-search',
    endpoint: '/product-projections/search',
    features: [search, queryOne, queryExpand, projection]
  },
  productProjectionsSuggest: {
    type: 'product-projections-suggest',
    endpoint: '/product-projections/suggest',
    features: [search, suggest, queryOne, projection]
  },
  products: {
    type: 'products',
    endpoint: '/products',
    features: [query, queryOne, queryExpand]
  },
  productTypes: {
    type: 'product-types',
    endpoint: '/product-types',
    features: [query, queryOne, queryExpand]
  },
  project: {
    type: 'project',
    endpoint: '/',
    features: [query]
  },
  reviews: {
    type: 'reviews',
    endpoint: '/reviews',
    features: [query, queryOne, queryExpand]
  },
  shippingMethods: {
    type: 'shipping-methods',
    endpoint: '/shipping-methods',
    features: [query, queryOne, queryExpand, queryLocation]
  },
  shoppingLists: {
    type: 'shopping-lists',
    endpoint: '/shopping-lists',
    features: [query, queryOne, queryExpand]
  },
  states: {
    type: 'states',
    endpoint: '/states',
    features: [query, queryOne, queryExpand]
  },
  subscriptions: {
    type: 'subscriptions',
    endpoint: '/subscriptions',
    features: [query, queryOne, queryExpand]
  },
  taxCategories: {
    type: 'tax-categories',
    endpoint: '/tax-categories',
    features: [query, queryOne, queryExpand]
  },
  types: {
    type: 'types',
    endpoint: '/types',
    features: [query, queryOne, queryExpand]
  },
  zones: {
    type: 'zones',
    endpoint: '/zones',
    features: [query, queryOne, queryExpand]
  }
};

/*       */

/**
 * Return the default parameters for building a query string.
 *
 * @return {Object}
 */
function getDefaultQueryParams() {
  return {
    id: null,
    expand: [],
    pagination: {
      page: null,
      perPage: null,
      sort: []
    },
    location: {
      currency: '',
      country: '',
      state: ''
    },
    query: {
      operator: 'and',
      where: []
    },
    searchKeywords: []
  };
}

/**
 * Return the default parameters for building a query search string.
 *
 * @return {Object}
 */
function getDefaultSearchParams() {
  return {
    expand: [],
    searchKeywords: [],
    staged: true,
    pagination: {
      page: null,
      perPage: null,
      sort: []
    },
    search: {
      facet: [],
      filter: [],
      filterByQuery: [],
      filterByFacets: [],
      fuzzy: false,
      fuzzyLevel: 0,
      markMatchingVariants: false,
      text: null
    }
  };
}

/**
 * Set the default parameters given the current service object.
 *
 * @return {void}
 */
function setDefaultParams() {
  this.params.expand = getDefaultQueryParams().expand;

  if (this.features.indexOf(queryOne) !== -1) this.params.id = getDefaultQueryParams().id;

  if (this.features.indexOf(query) !== -1) {
    this.params.pagination = getDefaultQueryParams().pagination;
    this.params.query = getDefaultQueryParams().query;
  }

  if (this.features.indexOf(search) !== -1) {
    this.params.staged = getDefaultSearchParams().staged;
    this.params.pagination = getDefaultSearchParams().pagination;
    this.params.search = getDefaultSearchParams().search;
  }

  if (this.features.indexOf(queryLocation) !== -1) this.params.location = getDefaultQueryParams().location;

  if (this.features.indexOf(projection) !== -1) this.params.staged = true;

  if (this.features.indexOf(suggest) !== -1) this.params.searchKeywords = [];
}

var hasKey = function hasKey(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
};

/**
 * Set the supplied parameters given the current service object.
 *
 * @return {void}
 */
function setParams(params) {
  var _this = this;

  // verify params
  var knownKeys = ['expand', 'id', 'key', 'customerId', 'cartId', 'sort', 'page', 'perPage', 'staged', 'priceCurrency', 'priceCountry', 'priceCustomerGroup', 'priceChannel', 'text', 'fuzzy', 'fuzzyLevel', 'markMatchingVariants', 'facet', 'filter', 'filterByQuery', 'filterByFacets', 'searchKeywords', 'where', 'whereOperator', 'version', 'country', 'currency', 'state'];
  Object.keys(params).forEach(function (key) {
    if (!(knownKeys.indexOf(key) !== -1)) throw new Error('Unknown key "' + key + '"');
  });

  // query-expand
  if (params.expand) params.expand.forEach(function (expansion) {
    _this.expand(expansion);
  });

  // query-id
  if (hasKey(params, 'id')) this.byId(params.id);
  if (hasKey(params, 'key')) this.byKey(params.key);
  if (hasKey(params, 'customerId')) this.byCustomerId(params.customerId);
  if (hasKey(params, 'cartId')) this.byCartId(params.cartId);

  // query-location
  if (hasKey(params, 'country')) this.byCountry(params.country);
  if (hasKey(params, 'currency')) this.byCurrency(params.currency);
  if (hasKey(params, 'state')) this.byState(params.state);

  // query-page
  if (params.sort) params.sort.forEach(function (sortDesc) {
    _this.sort(sortDesc.by, sortDesc.direction === 'asc');
  });
  if (hasKey(params, 'page')) this.page(params.page);
  if (hasKey(params, 'perPage')) this.perPage(params.perPage);

  // query-projection
  if (hasKey(params, 'staged')) this.staged(params.staged);
  if (hasKey(params, 'priceCurrency')) this.priceCurrency(params.priceCurrency);
  if (hasKey(params, 'priceCountry')) this.priceCountry(params.priceCountry);
  if (hasKey(params, 'priceCustomerGroup')) this.priceCustomerGroup(params.priceCustomerGroup);
  if (hasKey(params, 'priceChannel')) this.priceChannel(params.priceChannel);

  // query-search
  if (params.text) this.text(params.text.value, params.text.language);
  if (params.fuzzy) this.fuzzy(); // boolean switch
  if (hasKey(params, 'fuzzyLevel')) this.fuzzyLevel(params.fuzzyLevel);
  if (params.markMatchingVariants) this.markMatchingVariants(); // boolean switch
  if (params.facet) params.facet.forEach(function (facet) {
    _this.facet(facet);
  });
  if (params.filter) params.filter.forEach(function (filter) {
    _this.filter(filter);
  });
  if (params.filterByQuery) params.filterByQuery.forEach(function (query$$1) {
    _this.filterByQuery(query$$1);
  });
  if (params.filterByFacets) params.filterByFacets.forEach(function (facet) {
    _this.filterByFacets(facet);
  });

  // query-suggest
  if (params.searchKeywords) params.searchKeywords.forEach(function (searchKeyword) {
    _this.searchKeywords(searchKeyword.value, searchKeyword.language);
  });

  // query
  if (params.where) params.where.forEach(function (predicate) {
    _this.where(predicate);
  });
  if (hasKey(params, 'whereOperator')) this.whereOperator(params.whereOperator);

  // version
  if (hasKey(params, 'version')) this.withVersion(params.version);
}

/**
 * Given an object, return a clone with non-function properties defined as
 * non-enumerable, unwritable, and unconfigurable.
 *
 * @param {Object}
 * @return {Object}
 */
function classify(object) {
  var forceEnumerable = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

  var clone = {};

  Object.keys(object).forEach(function (key) {
    Object.defineProperty(clone, key, {
      value: object[key],
      enumerable: forceEnumerable ? true : typeof object[key] === 'function'
    });
  });

  return clone;
}

/*       */

/**
 * Build the query string with the given parameters.
 *
 * @param  {Object} params - An object with query / search parameters.
 * @throws If argument is missing.
 * @return {string} The fully encoded query string.
 */
function buildQueryString(params) {
  if (!params) throw new Error('Missing options object to build query string.');

  var query = params.query,
      pagination = params.pagination,
      search = params.search,
      expand = params.expand,
      staged = params.staged,
      priceCurrency = params.priceCurrency,
      priceCountry = params.priceCountry,
      priceCustomerGroup = params.priceCustomerGroup,
      priceChannel = params.priceChannel,
      searchKeywords = params.searchKeywords,
      version = params.version,
      customerId = params.customerId,
      cartId = params.cartId,
      location = params.location;

  var queryString = [];

  if (customerId) queryString.push('customerId=' + customerId);

  if (cartId) queryString.push('cartId=' + cartId);

  if (typeof staged === 'boolean') queryString.push('staged=' + staged.toString());

  if (priceCurrency) queryString.push('priceCurrency=' + priceCurrency);

  if (priceCountry) queryString.push('priceCountry=' + priceCountry);

  if (priceCustomerGroup) queryString.push('priceCustomerGroup=' + priceCustomerGroup);

  if (priceChannel) queryString.push('priceChannel=' + priceChannel);

  if (expand && expand.length) queryString = queryString.concat(expand.map(function (e) {
    return 'expand=' + e;
  }));

  if (query) {
    var operator = query.operator,
        where = query.where;

    var whereParams = where.join(encodeURIComponent(' ' + operator + ' '));
    if (whereParams) queryString.push('where=' + whereParams);
  }

  if (location) {
    var country = location.country,
        currency = location.currency,
        state = location.state;

    if (country) queryString.push('country=' + country);
    if (currency) queryString.push('currency=' + currency);
    if (state) queryString.push('state=' + state);
  }

  if (pagination) {
    var page = pagination.page,
        perPage = pagination.perPage,
        sort = pagination.sort;

    if (typeof perPage === 'number') queryString.push('limit=' + perPage);
    if (page) {
      var limitParam = perPage || 20;
      var offsetParam = limitParam * (page - 1);
      queryString.push('offset=' + offsetParam);
    }
    if (sort && sort.length) queryString = queryString.concat(sort.map(function (s) {
      return 'sort=' + s;
    }));
  }

  if (search) {
    var text = search.text,
        fuzzy = search.fuzzy,
        fuzzyLevel = search.fuzzyLevel,
        markMatchingVariants = search.markMatchingVariants,
        facet = search.facet,
        filter = search.filter,
        filterByQuery = search.filterByQuery,
        filterByFacets = search.filterByFacets;


    if (text) queryString.push('text.' + text.lang + '=' + text.value);
    if (fuzzy) queryString.push('fuzzy=true');
    if (fuzzyLevel) queryString.push('fuzzyLevel=' + fuzzyLevel);
    queryString.push('markMatchingVariants=' + markMatchingVariants.toString());

    facet.forEach(function (f) {
      return queryString.push('facet=' + f);
    });
    filter.forEach(function (f) {
      return queryString.push('filter=' + f);
    });
    filterByQuery.forEach(function (f) {
      return queryString.push('filter.query=' + f);
    });
    filterByFacets.forEach(function (f) {
      return queryString.push('filter.facets=' + f);
    });
  }

  if (searchKeywords) searchKeywords.forEach(function (f) {
    return queryString.push('searchKeywords.' + f.lang + '=' + f.value);
  });

  if (version) queryString.push('version=' + version);

  return queryString.join('&');
}

/*       */
/**
 * Set the `version` number to the internal state of the service instance
 * in order to generate a uri with the resource version (for example; to
 * perform a `DELETE` request)
 *
 * @param  {number} version - The version of the resource
 * @throws if `version` is missing or not a number.
 * @return {Object} The instance of the service, can be chained.
 */

function withVersion(version) {
  if (typeof version !== 'number') throw new Error('A resource version is missing or invalid');
  this.params.version = version;
  return this;
}

/**
 * Set the given `predicate` to the internal state of the service instance.
 *
 * @param  {string} predicate - A non-URI encoded string representing a
 * [Predicate]{@link http://dev.sphere.io/http-api.html#predicates}
 * @throws If `predicate` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function where(predicate) {
  if (!predicate) throw new Error('Required argument for `where` is missing');

  var encodedPredicate = encodeURIComponent(predicate);
  this.params.query.where.push(encodedPredicate);
  return this;
}

/**
 * Set the logical operator to combine multiple query predicates
 * {@link module:commons/query.where}
 *
 * @param  {string} operator - A logical operator `and`, `or`
 * @throws If `operator` is missing or has a wrong value.
 * @return {Object} The instance of the service, can be chained.
 */
function whereOperator(operator) {
  if (!operator) throw new Error('Required argument for `whereOperator` is missing');
  if (!(operator === 'and' || operator === 'or')) throw new Error('Required argument for `whereOperator` is invalid, ' + 'allowed values are (`and`, `or`)');

  this.params.query.operator = operator;
  return this;
}

var query$1 = Object.freeze({
	where: where,
	whereOperator: whereOperator
});

/*       */
/**
 * Set the given `id` to the internal state of the service instance.
 *
 * @param  {string} id - A resource `UUID`
 * @throws If `id` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function byId(id) {
  if (!id) throw new Error('Required argument for `byId` is missing');
  if (this.params.key) throw new Error('A key for this resource has already been set. ' + 'You cannot use both `byKey` and `byId`.');
  if (this.params.customerId) throw new Error('A customerId for this resource has already been set. ' + 'You cannot use both `byId` and `byCustomerId`.');

  if (this.params.cartId) throw new Error('A cartId for this resource has already been set. ' + 'You cannot use both `byId` and `byCartId`.');

  this.params.id = id;
  return this;
}

/**
 * Set the given `key` to the internal state of the service instance.
 *
 * @param  {string} key - A resource `key`
 * @throws If `key` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function byKey(key) {
  if (!key) throw new Error('Required argument for `byKey` is missing');
  if (this.params.id) throw new Error('An ID for this resource has already been set. ' + 'You cannot use both `byId` and `byKey`.');

  this.params.key = key;
  return this;
}

/**
 * Set the given `id` to the `customerId`internal state of the service instance.
 * For querying customer carts
 *
 * @param  {string} id - A resource `UUID`
 * @throws If `id` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function byCustomerId(custId) {
  if (!custId) throw new Error('Required argument for `byCustomerId` is missing');
  if (this.params.id) throw new Error('An ID for this resource has already been set. ' + 'You cannot use both `byId` and `byCustomerId`.');

  this.params.customerId = custId;
  return this;
}

/**
 * Set the given `id` to the `cartId` internal state of the service instance.
 * For querying shipping methods by cart id
 *
 * @param  {string} id - A resource `UUID`
 * @throws If `id` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function byCartId(cartId) {
  if (!cartId) throw new Error('Required argument for `byCartId` is missing');
  if (this.params.id) throw new Error('An ID for this resource has already been set. ' + 'You cannot use both `byId` and `byCartId`.');

  this.params.cartId = cartId;
  return this;
}

var queryId = Object.freeze({
	byId: byId,
	byKey: byKey,
	byCustomerId: byCustomerId,
	byCartId: byCartId
});

/*       */

/**
 * Set the given `country` param used for selection by country
 *
 * @param  {string} value - A two-digit country code as per ISO 3166-1 alpha-2
 * @return {Object} The instance of the service, can be chained.
 */
function byCountry(value) {
  if (!value) throw new Error('Required argument for `byCountry` is missing');

  this.params.location.country = value;
  return this;
}

/**
 * Set the given `currency` param used for selection by currency.
 *
 * @param  {string} value - The currency code compliant to ISO 4217
 * Can only be used with country parameter
 * @return {Object} The instance of the service, can be chained.
 */
function byCurrency(value) {
  if (!value) throw new Error('Required argument for `byCurrency` is missing');

  // logic to verify country has been set
  if (!this.params.location.country) throw new Error('A `country` for this resource has not been set. ' + 'You must set the country in order to use the `byCurrency` method.');

  this.params.location.currency = value;
  return this;
}

/**
 * Set the given `state` param used for selection by state.
 *
 * @param  {string} value - A string representing State name
 * Can only be used with country parameter
 * @return {Object} The instance of the service, can be chained.
 */
function byState(value) {
  if (!value) throw new Error('Required argument for `byState` is missing');

  // logic to verify country has been set
  if (!this.params.location.country) throw new Error('A `country` for this resource has not been set. ' + 'You must set the country in order to use the `byState` method.');

  this.params.location.state = value;
  return this;
}

var queryLocation$1 = Object.freeze({
	byCountry: byCountry,
	byCurrency: byCurrency,
	byState: byState
});

/*       */
/**
 * Set the
 * [ExpansionPath](http://dev.sphere.io/http-api.html#reference-expansion)
 * used for expanding a
 * [Reference](http://dev.sphere.io/http-api-types.html#reference)
 * of a resource.
 *
 * @param  {string} value - The expand path expression.
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
// eslint-disable-next-line import/prefer-default-export
function expand(value) {
  if (!value) throw new Error('Required argument for `expand` is missing');

  var encodedPath = encodeURIComponent(value);
  // Note: this goes to base `params`, not `params.query`
  // to be compatible with search.
  this.params.expand.push(encodedPath);
  return this;
}

var queryExpand$1 = Object.freeze({
	expand: expand
});

/*       */
/**
 * Set the sort expression for the query, if the related endpoint supports it.
 * It is possible to specify several `sort` parameters.
 * In this case they are combined into a composed `sort` where the results
 * are first sorted by the first expression, followed by equal values being
 * sorted according to the second expression, and so on.
 *
 * @param  {string} sortPath - The sort path expression.
 * @param  {boolean} [ascending] - Whether the direction should be
 * ascending or not (default: `true`).
 * @throws If `sortPath` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function sort(sortPath) {
  var ascending = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;

  if (!sortPath) throw new Error('Required argument for `sort` is missing');

  var direction = ascending ? 'asc' : 'desc';
  var encodedSort = encodeURIComponent(sortPath + ' ' + direction);
  this.params.pagination.sort.push(encodedSort);
  return this;
}

/**
 * Set the page number to be requested from the complete query result
 * (used for pagination as `offset`)
 *
 * @param  {string} value - The page number, greater then zero.
 * @throws If `value` is missing or is a number lesser then one.
 * @return {Object} The instance of the service, can be chained.
 */
function page(value) {
  if (typeof value !== 'number' && !value) throw new Error('Required argument for `page` is missing or invalid');

  if (typeof value !== 'number' || value < 1) throw new Error('Required argument for `page` must be a number >= 1');

  this.params.pagination.page = value;
  return this;
}

/**
 * Set the number of results to be returned from a query result
 * (used for pagination as `limit`)
 *
 * @param  {string} value - How many results in a page,
 * greater or equals then zero.
 * @throws If `value` is missing or is a number lesser then zero.
 * @return {Object} The instance of the service, can be chained.
 */
function perPage(value) {
  if (typeof value !== 'number' && !value) throw new Error('Required argument for `perPage` is missing or invalid');

  if (typeof value !== 'number' || value < 0) throw new Error('Required argument for `perPage` must be a number >= 0');

  this.params.pagination.perPage = value;
  return this;
}

var queryPage = Object.freeze({
	sort: sort,
	page: page,
	perPage: perPage
});

/*       */
/**
 * Define whether to get the staged or current projection
 *
 * @param  {boolean} staged - Either `true` (default) or `false`
 * (for current / published)
 * @return {Object} The instance of the service, can be chained.
 */
function staged() {
  var isStaged = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;

  this.params.staged = isStaged;
  return this;
}

/**
 * Define whether to set price Selection or not
 * Set the given `priceCurrency` param used for price selection.
 *
 * @param  {string} value - The currency code compliant to ISO 4217
 * @return {Object} The instance of the service, can be chained.
 */
function priceCurrency(value) {
  this.params.priceCurrency = value;
  return this;
}

/**
 * Define whether to set price Selection or not
 * Set the given `priceCountry` param used for price selection.
 *
 * @param  {string} value - A two-digit country code as per ISO 3166-1 alpha-2
 * Can only be used with priceCurrency parameter
 * @return {Object} The instance of the service, can be chained.
 */
function priceCountry(value) {
  this.params.priceCountry = value;
  return this;
}

/**
 * Define whether to set price Selection or not
 * Set the given `priceCustomerGroup` param used for price selection.
 *
 * @param  {string} value - price customer group UUID
 * Can only be used with priceCurrency parameter
 * @return {Object} The instance of the service, can be chained.
 */
function priceCustomerGroup(value) {
  this.params.priceCustomerGroup = value;
  return this;
}

/**
 * Define whether to set price Selection or not
 * Set the given `priceChannel` param used for price selection.
 *
 * @param  {string} value - price channel UUID
 * Can only be used with priceCurrency parameter
 * @return {Object} The instance of the service, can be chained.
 */
function priceChannel(value) {
  this.params.priceChannel = value;
  return this;
}

var queryProjection = Object.freeze({
	staged: staged,
	priceCurrency: priceCurrency,
	priceCountry: priceCountry,
	priceCustomerGroup: priceCustomerGroup,
	priceChannel: priceChannel
});

/*       */
/**
 * Define a Suggestion used for matching tokens for product projections,
 * via a suggest tokenizer.
 *
 * The suggestions can be used to implement a basic auto-complete functionality.
 * The source of data for suggestions is the searchKeyword field in a product.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * text to search for.
 * @param  {string} lang - An ISO language tag, used for search
 * the given text in localized content.
 * @throws If `value` or `lang` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
// eslint-disable-next-line import/prefer-default-export
function searchKeywords(value, lang) {
  if (!value || !lang) throw new Error('Required arguments for `searchKeywords` are missing');

  this.params.searchKeywords.push({ lang: lang, value: encodeURIComponent(value) });
  return this;
}

var querySuggest = Object.freeze({
	searchKeywords: searchKeywords
});

/*       */
/**
 * Set the given `text` param used for full-text search.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * text to search for.
 * @param  {string} lang - An ISO language tag, used for search
 * the given text in localized content.
 * @throws If `value` or `lang` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function text(value, lang) {
  if (!value || !lang) throw new Error('Required arguments for `text` are missing');

  this.params.search.text = { lang: lang, value: encodeURIComponent(value) };
  return this;
}

/**
 * Define whether to enable the fuzzy search.
 *
 * @return {Object} The instance of the service, can be chained.
 */
function fuzzy() {
  this.params.search.fuzzy = true;
  return this;
}

/**
 * Define the level of the fuzzy search
 *
 * @param  {number} value - An integer representing the fuzzy level
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function fuzzyLevel(value) {
  if (!value) throw new Error('Required argument for `fuzzyLevel` is missing');
  this.params.search.fuzzyLevel = value;
  return this;
}

/**
 * Define whether to enable markMatchingVariants
 *
 * @return {Object} The instance of the service, can be chained.
 */
function markMatchingVariants() {
  this.params.search.markMatchingVariants = true;
  return this;
}

/**
 * Set the given `facet` filter used for calculating statistical counts.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * facet expression.
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function facet(value) {
  if (!value) throw new Error('Required argument for `facet` is missing');

  var encodedFacet = encodeURIComponent(value);
  this.params.search.facet.push(encodedFacet);
  return this;
}

/**
 * Set the given `filter` param used for filtering search results.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * filter expression.
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function filter(value) {
  if (!value) throw new Error('Required argument for `filter` is missing');

  var encodedFilter = encodeURIComponent(value);
  this.params.search.filter.push(encodedFilter);
  return this;
}

/**
 * Set the given `filter.query` param used for filtering search results.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * filter by query expression.
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function filterByQuery(value) {
  if (!value) throw new Error('Required argument for `filterByQuery` is missing');

  var encodedFilter = encodeURIComponent(value);
  this.params.search.filterByQuery.push(encodedFilter);
  return this;
}

/**
 * Set the given `filter.facets` param used for filtering search results.
 *
 * @param  {string} value - A non-URI encoded string representing a
 * filter by query expression.
 * @throws If `value` is missing.
 * @return {Object} The instance of the service, can be chained.
 */
function filterByFacets(value) {
  if (!value) throw new Error('Required argument for `filterByFacets` is missing');

  var encodedFilter = encodeURIComponent(value);
  this.params.search.filterByFacets.push(encodedFilter);
  return this;
}

var querySearch = Object.freeze({
	text: text,
	fuzzy: fuzzy,
	fuzzyLevel: fuzzyLevel,
	markMatchingVariants: markMatchingVariants,
	facet: facet,
	filter: filter,
	filterByQuery: filterByQuery,
	filterByFacets: filterByFacets
});

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};

/*       */
var requiredDefinitionProps = ['type', 'endpoint', 'features'];

function getIdOrKey(params) {
  if (params.id) return '/' + params.id;else if (params.key) return '/key=' + params.key;
  return '';
}

function createService(definition) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

  if (!definition) throw new Error('Cannot create a service without its definition.');

  requiredDefinitionProps.forEach(function (key) {
    if (!definition[key]) throw new Error('Definition is missing required parameter ' + key + '.');
  });

  if (!Array.isArray(definition.features) || !definition.features.length) throw new Error('Definition requires `features` to be a non empty array.');

  if (!options) throw new Error('No project defined. Please enter a project key');

  var type = definition.type,
      endpoint = definition.endpoint,
      features = definition.features;


  return classify(_extends({
    type: type,
    features: features,
    params: getDefaultQueryParams(),
    withVersion: withVersion

  }, features.reduce(function (acc, feature) {
    if (feature === query) return _extends({}, acc, query$1, queryPage);

    if (feature === queryOne) return _extends({}, acc, queryId);

    if (feature === queryLocation) return _extends({}, acc, queryLocation$1);

    if (feature === queryExpand) return _extends({}, acc, queryExpand$1);

    if (feature === search) return _extends({}, acc, querySearch, queryPage, {
      params: getDefaultSearchParams()
    });

    if (feature === suggest) return _extends({}, acc, querySearch, queryPage, querySuggest);

    if (feature === projection) return _extends({}, acc, queryProjection);

    return acc;
  }, {}), {

    // Call this method to get the built request URI
    // Pass some options to further configure the URI:
    // - `withProjectKey: false`: will omit the projectKey from the URI
    build: function build() {
      var uriOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { withProjectKey: true };
      var withProjectKey = uriOptions.withProjectKey;


      var queryParams = buildQueryString(this.params);

      var uri = (withProjectKey ? '/' + options : '') + endpoint +
      // TODO this can lead to invalid URIs as getIdOrKey can return
      //   "/?customerId", so there can be multiple question marks,
      // same for when `queryParams` and `version` are present
      getIdOrKey(this.params) + (queryParams ? '?' + queryParams : '');

      setDefaultParams.call(this);
      return uri;
    },


    // Call this method to parse an object as params
    parse: function parse(params) {
      setParams.call(this, params);
      return this;
    }
  }));
}

/*       */
// pass an options argument of type object containing
// the `projectkey` (string) and `customServices` (object)
// The projectKey property is required
// A sample options object would be:
//
//     options: {
//       projectKey: 'myProject',
//       customServices: {
//         foo: {
//           type: 'foo',
//           endpoint: '/foo',
//           features: [
//             features.query,
//           ],
//         }
//       }
//     }
function createRequestBuilder() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var allServices = _extends({}, services, options.customServices);

  return Object.keys(allServices).reduce(function (acc, key) {
    return _extends({}, acc, defineProperty({}, key, createService(allServices[key], options.projectKey)));
  }, {});
}

// eslint-disable-next-line import/prefer-default-export

exports.features = features;
exports.createRequestBuilder = createRequestBuilder;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=commercetools-api-request-builder.umd.js.map
